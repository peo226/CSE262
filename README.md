# CSE262 - Programming Languages - Summer 2024

# Homework 5 & Final - Writing an Interpreter

**⏰ Due Date: 8/12/2024 NOON (NO EXTENSIONS POSSIBLE)**

## Instructions 

**Read thoroughly before starting your project:**

1. Fork this repository into your CSE262 project namespace. [Instructions](https://docs.gitlab.com/ee/workflow/forking_workflow.html#creating-a-fork)
2. Clone your newly forked repository onto your development machine. [Instructions](https://docs.gitlab.com/ee/gitlab-basics/start-using-git.html#clone-a-repository) 
3. As you are writing code you should commit patches along the way. *i.e.* don't just submit all your code in one big commit when you're all done. Commit your progress as you work. 

**💥IMPORTANT: You must commit frequently as you work on your project. As a general rule try to make at least one commit per function you implement.**

## Assignment

In this project you will write a grammar and a parser that recognizes the grammar. I've provided a number of statements in the language in `src/parser.rs`, which runs tests against your code. There are 28 tests you will need to pass to get full credit. You can think of each test as a question. If you write code that passes more than one test, just make a dummy commit to satisfy the commit requirement.

An example program in the Asa language looks like this:

```
let x = 1 + 1;
let y = 5 - 2;
let z = x + y;
```

1. `src/interpreter.rs` contains a partial implementation of the interpreter, which includes a `Value` enum, a `Interpreter` struct, and an implementation of the `exec()` function.

2. Th `Value` enum represents the different types of values that the interpreter can handle, including strings, numbers, and booleans.
The `Interpreter` struct represents the state of the interpreter at any given time, including the set of defined functions and the current stack of variable bindings.

3. You will need to complete the implementation of the interpreter by filling in the various match arms in the run function to handle the different types of AST nodes.

4. The comments in the code provide some guidance on what each match arm should do, but you may need to refer to the grammar and parser to understand the structure of the AST nodes.

5. As you work on the implementation, continually run the tests to ensure that the interpreter is working correctly. You can use the tests provided in `test/tests.rs` as a starting point, but you may need to write additional tests to cover specific cases.

# Final Exam

Implement the following conditional operators in your interpreter:

1) Greater-than (`>`)
2) Less-than (`<`)
3) Greater-than or Equal-to (`>=`)
4) Less-than or Equal-to (`<=`)
5) Equal-to (`==`)
6) Not Equal-to (`!=`)

A conditional expressions is a number, boolean, identifier or expression; followed by one of the noted operators below; followed by another number, boolean, identifier or expression. Here are some examples of valid and invalid conditional expressions.

Valid conditional expressions:

```
1 > 2
true == x // if x is boolean
x > y     // if both x and y are boolean
```
Invalid conditional expressions:

```
1 > true    // invalid beause you can't compare number and boolean
5 - false   // invalid because you can't do math on number and boolean
```

Here's an example demonstrating operator precedence, which you must take into account in your implementation:

```
let x = 10;
let y = 5 > x;
let result = y == true;
```

## Part 1 - Grammar / Lexer

In this part, you must:

- Update the grammar to include the syntax for the new operators
- Add any symbols to lexer to accomodate grammar updates.
- Define the meaning of the symbols you use to express your grammar. 

## Part 2 - Parser

In this part, you must:

1. Modify the existing parser to support the new grammar rules you defined in Part 1. This will involve adding new parser node variants.
2. Implement the necessary parser combinators for conditional operators.
3. Make parser update consistent with grammar updates.

## Part 3 - Interpreter

In this part, you must:

1. Modify the existing interpreter to support the new parser nodes generated by your parser. 
2. Implement the necessary evaluation rules for your conditional operators.
4. Ensure your interpreter returns informative error messages for invalid expressions or runtime errors.

## Part 4 - Tests

In this part you must: 

1. Write at least 10 new tests for your implementation.
2. Update any previous tests to accomodate your new additions.
3. Be sure your new tests increase test coverage and edge cases

## Recording

Create a screen recording of your interpreter, and demonstrate that it works. As part of your video, you should hit the following points:

- Describe what an interpreter its place is in the program execution pipeline.
- - The interpreter handles parsed tokens (which are compiled into Nodes) and executes code depending on what each of the nodes are. This process takes place after parsing, which is after lexing.
- Describe how you implemented the `exec()` function.
- How might you extend this interpreter in the future?
- - Add nested math expressions (as i mentioned in the parser) 
- - Fix string comparisons
- - Allow string comparing length

[VID LINK](https://drive.google.com/file/d/1abV7KQu81UI4lJ26hbVktF-iSbNtTRw3/view?usp=sharing)

To demonstrate it working, it's sufficient to show the output that is produced by the `exec()` function. Be sure to explain why the output your interpreter prints is the correct output.

If you did not successfully write the interpreter, you may show output for as far as you were able to get. Also, explain how you attempted to solve this assignment and describe where you got stuck. Show off any code you did write.

If you need any accomodations with this part of the assignment, please see me ASAP.

## Deliverables

1. Finish the interpreter that's started in `/src/interpreter.rs`. Then update the parser and lexer with new features.

2. Write 10 more tests in `test/tests.rs`. Make sure they increase test coverage; you want to add tests to verify things tha aren't tested already.

3. A recording link with permission to view granted to the link holder.

- Only files under version control in your forked assignment repository will be graded. Local files left untracked on your computer will not be considered.

- Only code committed *and pushed* prior to the time of grading will be accepted. Locally committed but unpushed code will not be considered.

- Your assignment will be graded according to the [Programming Assignment Grading Rubric](https://drive.google.com/open?id=1V0nBt3Rz6uFMZ9mIaFioLF-48DFX0VdkbgRUDM_eIFk).

Your submission should be organized, well-commented, and easy to understand. Remember to document any assumptions you made during the implementation process, as well as any limitations of your solution. Your final exam will be graded on the correctness, completeness, and clarity of your submission.